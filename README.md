# Currency Converter

После рефакторинга реализована архитектура Singleton для кэширования курсов валют и с минимизацией повторяющегося кода.

## Основные изменения и обоснование

### 1. Единый класс для конвертации
- **Что изменено:**  
  Вместо создания отдельных классов для каждой валюты, вся логика реализована в одном классе `CurrencyConverter`.
- **Обоснование:**  
  - Устраняет дублирование кода (принцип DRY).
  - Упрощает расширение функциональности – добавление новой валюты требует лишь передачи нового кода валюты в метод `convert`.

### 2. Использование паттерна Singleton для получения курсов валют
- **Что изменено:**  
  Курсы валют получаются один раз при первом вызове метода `_fetch_rates()` и сохраняются в статическом атрибуте `_rates`.
- **Обоснование:**  
  - Повышается производительность, так как API-запрос выполняется только один раз.
  - Обеспечивается единообразное использование данных курсов для всех последующих вызовов.

### 3. Единый логгер для всего класса
- **Что изменено:**  
  Логгер инициализируется один раз через метод `_init_logger()` и используется для всех операций конвертации и получения данных.
- **Обоснование:**  
  - Обеспечивает централизованное логирование.
  - Устраняет дублирование кода для настройки логгирования в разных частях проекта.
  - Улучшает отладку и мониторинг работы приложения.

### 4. Минимализм и чистота кода
- **Что изменено:**  
  Вся функциональность сгруппирована в одном классе с использованием вспомогательных методов (`_init_logger`, `_fetch_rates`, `_convert`).
- **Обоснование:**  
  - Соответствует принципам KISS и YAGNI, не перегружая систему избыточной структурой.
  - Код становится легче для понимания, сопровождения и тестирования.

## Соответствие принципам SOLID

- **Single Responsibility Principle:**  
  Класс `CurrencyConverter` отвечает только за получение курсов валют и их использование для конвертации, что обеспечивает единую ответственность за обработку обменных курсов и конвертацию суммы.

- **Open/Closed Principle:**  
  Класс легко расширяем: добавление поддержки новых валют не требует изменения существующего кода, достаточно передать новый код валюты в метод `convert`. При необходимости можно расширить функциональность, создав обертку вокруг базового класса.

- **Liskov Substitution Principle:**  
  Хотя в реализации используется единый класс, метод `convert` корректно обрабатывает разные типы валют, и любой клиентский код может использовать этот метод, не опасаясь некорректного поведения при передаче различных кодов валют.

- **Interface Segregation Principle:**  
  Интерфейс класса минималистичен: клиенту требуется только метод `convert`, что удовлетворяет потребностям конвертации без необходимости реализации дополнительных методов, которые не используются.

- **Dependency Inversion Principle:**  
  Класс `CurrencyConverter` зависит от абстрактного API для получения курсов (через вызов внешнего API) и использует встроенный механизм логгирования. В будущем можно заменить реализацию получения курсов без влияния на клиентский код.
